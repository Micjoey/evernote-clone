# This file should contain all the record creation needed to seed the database with its default values.
# The data can then be loaded with the rails db:seed command (or created alongside the database with db:setup).
#
# Examples:
#
#   movies = Movie.create([{ name: 'Star Wars' }, { name: 'Lord of the Rings' }])
#   Character.create(name: 'Luke', movie: movies.first)

User.destroy_all
Note.destroy_all
Notebook.destroy_all


user1 = User.create(email: "demo@nevernote.com", password:"password", name:"Demo User")

notebook1 = Notebook.create(title: "Coding Notes", user_id: user1.id)
notebook2 = Notebook.create(title: "Breakfast and Brunch Recipes", user_id: user1.id)


note1 = Note.create(title: "JavaScript Data Structures Notes", body: "<p>Next article in JavaScript DataFlair Tutorial Series will focus on different data structures in JavaScript. We will start with understanding what data structures are, then we will continue with its classification. Also, we will understand some of the basic data structures in a little more depth. But before we start with our tutorial on JavaScript Data Structure, we would recommend you to go through our previous tutorial on&nbsp;<a href=\"https://data-flair.training/blogs/javascript-array/\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: rgb(101, 171, 246);\"><em>JavaScript Array</em></a>. This is because you need to have a basic understanding of JavaScript to be able to understand this topic.</p><h2>What are JavaScript Data Structures?</h2><p>A JavaScript Data Structure is a specific technique to organize and store data in a computer so that we can access and modify it efficiently. More accurately, it is a collection of data values, the relationships among them, and the functions or operations that we can apply to the data.</p><p>Some of the advantages of using data structures are as follows:</p><ul><li>They provide an easy way to manage large datasets.</li><li>They simplify the processing of data on a computer.</li><li>These are essential for designing efficient program algorithms.</li></ul><p>But, only advanced users can make changes to data structures. So if you run into any problem, you’ll need an expert’s advice. The diagram below illustrates the types of data structures available in every programming language, including&nbsp;<em>JavaScript</em>. You will see some other data structures including&nbsp;trie, but these are advanced topics and it’s not relevant to mention them here.</p><p><a href=\"https://d2h0cx97tjks2p.cloudfront.net/blogs/wp-content/uploads/sites/2/2019/08/JavaScript-data-structures.png\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: rgb(101, 171, 246);\"><img src=\"https://d2h0cx97tjks2p.cloudfront.net/blogs/wp-content/uploads/sites/2/2019/08/JavaScript-data-structures.png\" alt=\"JavaScript-data-structures\" height=\"344\" width=\"582\"></a></p><h3>Types of Data Structures in JavaScript</h3><p>We discussed various primitive data structures that JavaScript provides in our prior tutorial on&nbsp;<a href=\"https://data-flair.training/blogs/javascript-data-types/\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: rgb(101, 171, 246);\"><em>Data Types in JavaScript</em></a>. This tutorial will focus on non-primitive data structures. They are as follows:</p><ul><li>A&nbsp;linear data structure&nbsp;traverses its elements sequentially. We can reach only one data item directly. To access other elements, you need the help of that base element.</li><li>Unlike linear data structures,&nbsp;non-linear data structures&nbsp;don’t traverse in a sequence. Every data item connects with numerous other items, reflecting specific relationships.</li><li>Static data structures&nbsp;have a fixed memory size, that is, you need to state the maximum size of the structure well in advance. We cannot allocate the memory later. The example of static data structure is arrays. We learned about them in the DataFlair’s previous tutorial on JavaScript Arrays.</li><li>Dynamic data structures&nbsp;differ from static data structures in the way that we can modify the memory size allocated to it. These include&nbsp;<em>queue, stack and linked lists</em>.</li></ul><p>The following table states the difference between static and dynamic data structures very clearly.</p><p class=\"ql-align-center\">Static Data StructuresDynamic Data Structures</p><p>Memory is either wasted (underflow) or is insufficient (overflow).The amount of memory allocated varies, preventing memory wastage.</p><p>Fast access to the data elements since the memory location is decided while writing the program.Slower access to each element since memory allocation happens at run time.</p><p>Structures have fixed size, making them predictable and easier to work with.Structures vary in size, thus complex algorithms are necessary to deal with them.</p><p>The relationship between different elements remains constant.The relationship between the elements changes as the program executes.</p><h3>1. Linked List</h3><p>A linked list maintains a list in the memory. The script has the base address of the first element, that contains the link to the next element in the list. You can only access an element (except the base element) using the previous element.</p><p><a href=\"https://d2h0cx97tjks2p.cloudfront.net/blogs/wp-content/uploads/sites/2/2019/08/Linked-List-1.png\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: rgb(101, 171, 246);\"><img src=\"https://d2h0cx97tjks2p.cloudfront.net/blogs/wp-content/uploads/sites/2/2019/08/Linked-List-1.png\" alt=\"Linked List - JavaScript Data Structures\" height=\"144\" width=\"688\"></a></p><p>Linked lists store these elements in what we call a&nbsp;node. A node comprises of a&nbsp;data value&nbsp;and the link (address) to the next element. The first node is the&nbsp;head&nbsp;while the last node is the&nbsp;tail&nbsp;of the list. The tail, as shown in the diagram, contains the value&nbsp;NULL&nbsp;in place of a link. The code below creates a node:</p><p>Code:</p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;html&gt;
  &lt;body&gt;

    &lt;script&gt;
      class Node { //defining a JavaScript class
          constructor(data) { //constructor method
              this.data = data; //data value of the node
              this.next = null; //link of the next node
          }
      }
      const head = new Node(12); //creating a node
    &lt;/script&gt;

  &lt;/body&gt;
&lt;/html&gt;
</pre><p>Screenshot:</p><p><a href=\"https://d2h0cx97tjks2p.cloudfront.net/blogs/wp-content/uploads/sites/2/2019/07/node.datastructure.jpg\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: rgb(101, 171, 246);\"><img src=\"https://d2h0cx97tjks2p.cloudfront.net/blogs/wp-content/uploads/sites/2/2019/07/node.datastructure.jpg\" alt=\"node.datastructure\" height=\"744\" width=\"1298\"></a></p><p>Output:</p><p><a href=\"https://d2h0cx97tjks2p.cloudfront.net/blogs/wp-content/uploads/sites/2/2019/07/node.datastructure-op.jpg\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: rgb(101, 171, 246);\"><img src=\"https://d2h0cx97tjks2p.cloudfront.net/blogs/wp-content/uploads/sites/2/2019/07/node.datastructure-op.jpg\" alt=\"node.datastructure op\" height=\"740\" width=\"1300\"></a></p><p>Let’s add another node in our code with the following statement at the end of the script:</p><ol><li><span style=\"color: rgb(0, 0, 0);\">head.next = new </span><strong style=\"color: rgb(63, 127, 149);\">Node</strong><span style=\"color: rgb(119, 119, 119);\">(</span><span style=\"color: rgb(0, 0, 0);\">45</span><span style=\"color: rgb(119, 119, 119);\">)</span><span style=\"color: rgb(0, 0, 0);\">;</span></li></ol><p>The&nbsp;output&nbsp;in your console window will look something like this:</p><p><a href=\"https://d2h0cx97tjks2p.cloudfront.net/blogs/wp-content/uploads/sites/2/2019/07/node.datastructure-op2.jpg\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: rgb(101, 171, 246);\"><img src=\"https://d2h0cx97tjks2p.cloudfront.net/blogs/wp-content/uploads/sites/2/2019/07/node.datastructure-op2.jpg\" alt=\"node.datastructure op2\" height=\"742\" width=\"1300\"></a></p><p>Note that now the&nbsp;next&nbsp;of the first element contains the link of the subsequent element.</p><p>There is a more efficient way to add several nodes to a linked list effectively, but they are not part of basic JavaScript. As you grow as a programmer, you will gain a better understanding of how it works.</p><h3>2. Stack</h3><p><a href=\"https://d2h0cx97tjks2p.cloudfront.net/blogs/wp-content/uploads/sites/2/2019/07/stack.png\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: rgb(101, 171, 246);\"><img src=\"https://d2h0cx97tjks2p.cloudfront.net/blogs/wp-content/uploads/sites/2/2019/07/stack.png\" alt=\"stack - JavaScript Conditional Statements\" height=\"284\" width=\"389\"></a></p><p>A stack is an ordered list which follows&nbsp;LIFO&nbsp;(last in first out) algorithm. You can access the elements of a stack from only a single end, called&nbsp;top. A very common example of a stack, we see in our daily lives, is the stack of chairs. You can only access the top chair at a time. The only way to reach a chair in the middle is by going through all the chairs above it. In our very first tutorial on&nbsp;<a href=\"https://data-flair.training/blogs/javascript-tutorial/\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: rgb(101, 171, 246);\"><em>Introduction to JavaScript</em></a>, we learned about the call stack which works with the instructions we want to execute. Stacks are crucial for programming, so you must know them well because you are going to work with them a lot while developing.</p><p>We can implement a stack using a static data structure (array) or a linked list. Both approaches have their own advantages but as a beginner, we will implement stack using an array. The code below creates a new stack and pushes two elements in the stack using the predefined&nbsp;push()&nbsp;function:</p><p>Code:</p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;html&gt;
  &lt;body&gt;

    &lt;script&gt;
      let stack = []; //create empty stack using array
      //push
      stack.push(65);
      stack.push(10);
    &lt;/script&gt;

  &lt;/body&gt;
&lt;/html&gt;
</pre><p>Screenshot:</p><p><a href=\"https://d2h0cx97tjks2p.cloudfront.net/blogs/wp-content/uploads/sites/2/2019/07/stack.jpg\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: rgb(101, 171, 246);\"><img src=\"https://d2h0cx97tjks2p.cloudfront.net/blogs/wp-content/uploads/sites/2/2019/07/stack.jpg\" alt=\"stack\" height=\"742\" width=\"1298\"></a></p><p>I removed the top element from my stack directly from the console using the&nbsp;pop()&nbsp;function. You can add the statement in your source code as well. The&nbsp;output&nbsp;will look something like this:</p><p><a href=\"https://d2h0cx97tjks2p.cloudfront.net/blogs/wp-content/uploads/sites/2/2019/07/stack-op.jpg\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: rgb(101, 171, 246);\"><img src=\"https://d2h0cx97tjks2p.cloudfront.net/blogs/wp-content/uploads/sites/2/2019/07/stack-op.jpg\" alt=\"stack op\" height=\"741\" width=\"1301\"></a></p><h3>3. Queue</h3><p><a href=\"https://d2h0cx97tjks2p.cloudfront.net/blogs/wp-content/uploads/sites/2/2019/08/queue.png\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: rgb(101, 171, 246);\"><img src=\"https://d2h0cx97tjks2p.cloudfront.net/blogs/wp-content/uploads/sites/2/2019/08/queue.png\" alt=\"queue - JavaScript Data Structures\" height=\"143\" width=\"553\"></a></p><p>A queue is another type of ordered list which follows&nbsp;FIFO&nbsp;(first in first out) algorithm. It has two ends,&nbsp;front&nbsp;(elements added) and&nbsp;rear&nbsp;(elements removed). A common example you may see is a queue of cars in a one-way lane. The first car that enters the lane is the first one to exit. Also, the car in the middle cannot exit the queue until all the cars before it.</p><p>The process of inserting an element in the queue is&nbsp;enqueueing&nbsp;while removing an element is&nbsp;dequeuing.&nbsp;Similar to stacks, we can implement queues with the help of both an array and a linked list. Both approaches have their pros and cons, as explained in the difference between static and dynamic data structures. The array implementation of a queue is clear in the example below. Note that I performed dequeue directly on the Browser Console Window.</p><p>Code:</p><pre class=\"ql-syntax\" spellcheck=\"false\">&lt;html&gt;
  &lt;body&gt;

    &lt;script&gt;
      let queue = []; //create an empty queue
      //enqueue
      queue.push(65);
      queue.push(10);
    &lt;/script&gt;

  &lt;/body&gt;
&lt;/html&gt;
</pre><p>Screenshot:</p><p><a href=\"https://d2h0cx97tjks2p.cloudfront.net/blogs/wp-content/uploads/sites/2/2019/07/queue.jpg\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: rgb(101, 171, 246);\"><img src=\"https://d2h0cx97tjks2p.cloudfront.net/blogs/wp-content/uploads/sites/2/2019/07/queue.jpg\" alt=\"queue\" height=\"740\" width=\"1300\"></a></p><p>Output:</p><h3><a href=\"https://d2h0cx97tjks2p.cloudfront.net/blogs/wp-content/uploads/sites/2/2019/07/queue-op.jpg\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: rgb(101, 171, 246);\"><img src=\"https://d2h0cx97tjks2p.cloudfront.net/blogs/wp-content/uploads/sites/2/2019/07/queue-op.jpg\" alt=\"queue op\" height=\"742\" width=\"1298\"></a></h3><h3>4. Tree</h3><p><a href=\"https://d2h0cx97tjks2p.cloudfront.net/blogs/wp-content/uploads/sites/2/2019/08/JavaScript-root-node.png\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: rgb(101, 171, 246);\"><img src=\"https://d2h0cx97tjks2p.cloudfront.net/blogs/wp-content/uploads/sites/2/2019/08/JavaScript-root-node.png\" alt=\"root node - JavaScript data structures\" height=\"327\" width=\"516\"></a></p><p>A JavaScript tree is a special data structure that implements the hierarchical tree structure with a root node, child and parent nodes and leaf nodes represented as a set of linked nodes. A tree data structure is a collection of nodes, starting with a root node, with data values in each of the nodes along with the reference to the child nodes. The root node has no parent node and the leaf nodes have no child nodes. If the child node of a parent node has one or more child nodes, it is a subtree. In the diagram above, the nodes&nbsp;BEF&nbsp;(T1) and&nbsp;DGH&nbsp;(T2) form two subtrees.</p><h3>5. Graph</h3><p>A graph is a group of a finite number of vertices and edges that connect these vertices. The edges can be&nbsp;‘directed’&nbsp;(directed graph) and&nbsp;‘undirected’&nbsp;(undirected graph). Unlike trees, who maintain a parent-child relationship between their nodes (vertices), the nodes of the graph maintain a complex relationship among them.</p><h3><a href=\"https://d2h0cx97tjks2p.cloudfront.net/blogs/wp-content/uploads/sites/2/2019/08/directed-undirected-graph-1.png\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: rgb(101, 171, 246);\"><img src=\"https://d2h0cx97tjks2p.cloudfront.net/blogs/wp-content/uploads/sites/2/2019/08/directed-undirected-graph-1.png\" alt=\"directed undirected graph - JavaScript Data Structures\" height=\"287\" width=\"544\"></a></h3><h3>6. Hash table</h3><p><a href=\"https://d2h0cx97tjks2p.cloudfront.net/blogs/wp-content/uploads/sites/2/2019/08/hash-table.png\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: rgb(101, 171, 246);\"><img src=\"https://d2h0cx97tjks2p.cloudfront.net/blogs/wp-content/uploads/sites/2/2019/08/hash-table.png\" alt=\"hash table - JavaScript Data Structures\" height=\"269\" width=\"564\"></a></p><p>A hash table, or hash map, is a data structure that implements associative arrays since it maps keys to values. It uses a hash function to determine the index of the data value in the array (bucket). These buckets help to identify the storage location of the data we want. The earlier version of&nbsp;<a href=\"https://en.wikipedia.org/wiki/JavaScript\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: rgb(101, 171, 246);\">JavaScript</a>&nbsp;didn’t support associative arrays, so there was no built-in hash table available. But as the developers introduced new features, JavaScript gained additional functionality and addition of associative arrays was one of them.</p><p><br></p><h2>Summary</h2><p>Here we conclude our tutorial on JavaScript Data Structures. In this article, we learned about some of the data structures of JavaScript. There are many more you will learn about as you practice JavaScript, but for now, these are the ones you need to focus on. Be very attentive when you learn or practice about these structures since these are common for all programming languages. Once you clear your concepts, all that is left is the syntax of the program, and that is quite easy.</p><p><br></p><p><br></p><p><br></p>", user_id: user1.id, notebook_id: notebook1.id)

note2= Note.create(title: "Graph Theory Notes", body: "<p><strong>Graph Theory</strong>&nbsp;is the study of lines and points.</p><p>It is a sub-field of mathematics which deals with graphs: diagrams that involve points and lines and which often pictorially represent mathematical truths. Graph theory is the study of the relationship between&nbsp;<strong>edges</strong>&nbsp;and&nbsp;<strong>vertices</strong>. Formally, a graph is a pair (V, E), where V is a&nbsp;<a href=\"https://calculushowto.com/finite-set-and-infinite-sets/\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: rgb(5, 169, 197);\">finite set&nbsp;</a>of vertices and E a finite set of edges.</p><p><a href=\"https://www.statisticshowto.com/wp-content/uploads/2016/01/kruskals-algorithm-3.png\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: rgb(5, 169, 197);\"><img src=\"https://www.statisticshowto.com/wp-content/uploads/2016/01/kruskals-algorithm-3.png\" alt=\"graph theory\" height=\"136\" width=\"300\"></a></p><p><em>A minimum spanning tree. The edges form straight lines between vertices (nodes).</em></p><h2>Definitions in Graph Theory</h2><p>Graph Theory has some unique vocabulary:</p><ul><li>An&nbsp;<strong>arc</strong>&nbsp;is a directed line (a pair of ordered vertices).</li><li>An&nbsp;<strong>edge</strong>&nbsp;is line joining a pair of nodes.</li><li class=\"ql-indent-1\"><strong>Incident</strong>&nbsp;edges are edges which share a vertex. A edge and vertex are&nbsp;<strong>incident</strong>&nbsp;if the edge connects the vertex to another.</li><li>A&nbsp;<strong>loop</strong>&nbsp;is an edge or arc that joins a vertex to itself.</li><li><span style=\"color: rgb(119, 119, 119);\">A&nbsp;</span><strong style=\"color: rgb(119, 119, 119);\">vertex</strong><span style=\"color: rgb(119, 119, 119);\">,</span>&nbsp;sometimes called a&nbsp;<strong>node</strong>, is a point or circle. It is the fundamental unit from which graphs are made.</li><li class=\"ql-indent-1\"><strong>Adjacent</strong>&nbsp;vertices are vertices which are connected by an edge.</li><li class=\"ql-indent-1\">The&nbsp;<strong>degree</strong>&nbsp;of a vertex is simply the number of edges that connect to that vertex. Loops count twice.</li><li class=\"ql-indent-1\">A&nbsp;<strong>predecessor</strong>&nbsp;is the node (vertex) before a given vertex on a path.</li><li class=\"ql-indent-1\">A&nbsp;<strong>successor</strong>&nbsp;is the node (vertex) following a given vertex on a path.</li><li><strong>A walk</strong>&nbsp;is a series of vertices and edges.</li><li class=\"ql-indent-1\">A&nbsp;<strong>circuit</strong>&nbsp;is a closed walk with every edge distinct.</li><li class=\"ql-indent-1\">A&nbsp;<strong>closed walk</strong>&nbsp;is a walk from a vertex back to itself; a series of vertices and edges which begins and ends at the same place.</li><li class=\"ql-indent-1\">A&nbsp;<strong>cycle</strong>&nbsp;is a closed walk with no repeated vertices (except that the first and last vertices are the same).</li><li class=\"ql-indent-1\">A&nbsp;<strong>path</strong>&nbsp;is a walk where no repeated vertices. A&nbsp;<strong>u-v</strong>&nbsp;path is a path beginning at u and ending at v.</li><li class=\"ql-indent-1\">A&nbsp;<strong>u-v walk</strong>&nbsp;would be a walk beginning at u and ending at v.</li></ul><h2>More Definitions:</h2><ul><li>An&nbsp;<strong>edge contraction</strong>&nbsp;involves removing an edge from a graph by merging the two vertices it used to join.</li><li>In computer science and computer-based graph theory, a&nbsp;<strong>graph traversal</strong>&nbsp;is an exploration of a graph in which the vertices are visited or updated one by one.</li><li>A&nbsp;<a href=\"https://www.statisticshowto.com/hamiltonian-cycle/\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: rgb(119, 119, 119);\"><strong>Hamiltonian cycle</strong></a>&nbsp;is a closed loop where every node is visited exactly once.</li></ul><h2>Types of Graphs</h2><ul><li>An&nbsp;<a href=\"https://www.statisticshowto.com/directed-acyclic-graph/\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: rgb(119, 119, 119);\"><strong>acyclic directed graph</strong></a>&nbsp;is a finite directed graph which has no directed cycles.</li><li>A&nbsp;<strong>directed graph</strong>&nbsp;is a graph where the edges have direction; that is, they are ordered pairs of vertices.</li><li>A&nbsp;<strong>condensation</strong>&nbsp;of a multigraph is the graph that results when you delete any multiple edges, leaving just one edge between any two points.</li><li>If a graph has a path between every pair of vertices (there is no vertex not connected with an edge), the graph is called a&nbsp;<strong>connected graph</strong>.</li><li>If a graph G’ can be constructed from a graph G by repeated edge contractions or deletions, the graph G’ is a&nbsp;<strong>graph minor</strong>&nbsp;of G.</li><li>An&nbsp;<strong>inverted graph</strong>&nbsp;G’ of G is a graph with the same vertices but none of the same edges; two vertices in G’ are adjacent if and only if they were not adjacent in G.</li><li>A&nbsp;<strong>multigraph</strong>&nbsp;is a graph without loops, but which may have multiple edges.</li><li>A&nbsp;<strong>null graph</strong>&nbsp;is a graph with no edges. It may have one or more vertices.</li><li>An&nbsp;<strong>oriented graph</strong>&nbsp;is a directed graph that doesn’t have any symmetric pairs of directed edges.</li><li>A&nbsp;<strong>simple graph</strong>&nbsp;is a graph that doesn’t have any loops or multiple edges. No multiple edges means that no two edges have the same endpoints.</li><li>A&nbsp;<strong>subgraph</strong>&nbsp;is a graph whose vertices and edges are included in the vertices and edges of another graph (the&nbsp;<strong>supergraph</strong>).</li><li>A&nbsp;<strong>symmetric graph</strong>&nbsp;is a directed graph D where, for every arc (x,y), the inverted arc (y,x) is also in D.</li><li>A&nbsp;<strong>trivial graph</strong>&nbsp;is a graph with only one vertex.</li><li>An&nbsp;<strong>undirected graph</strong>&nbsp;is a graph where none of the edges have direction; the pairs of vertices that make up each edge are unordered.</li></ul><h2>Graph Theory in History</h2><p>Graph Theory dates back to 1735 and&nbsp;<a href=\"https://www.maa.org/press/periodicals/convergence/leonard-eulers-solution-to-the-konigsberg-bridge-problem\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: rgb(5, 169, 197);\">Euler’s Seven Bridges of Königsberg</a>. The city of Königsberg was a town with two islands, connected to each other and to the mainland by seven bridges. The question set was whether it were possible to take a walk and cross each bridge exactly once. In a first demonstration of graph theory, Euler showed that it was not possible.</p><p><a href=\"https://www.statisticshowto.com/wp-content/uploads/2017/07/euler.png\" rel=\"noopener noreferrer\" target=\"_blank\" style=\"color: rgb(5, 169, 197);\"><img src=\"https://www.statisticshowto.com/wp-content/uploads/2017/07/euler.png\" height=\"327\" width=\"671\"></a></p><p><em>From: ‘Solutio problematis ad geometriam situs pertinentis,’ Eneström 53 </em></p><p><br></p><h2>Mantel’s Theorem</h2><p>Mantel’s theorem, published in 1907, tells us the largest number of edges a graph with a given number of vertices may have without having a triangle for a subgraph. It can be stated as:</p><p><em>A graph with n vertices and m edges will contain a triangle as a subgraph if and only if m &gt; n2/4</em>.</p></div><div class=\"ql-clipboard\" contenteditable=\"true\" tabindex=\"-1\"></div><div class=\"ql-tooltip ql-hidden\" style=\"left: 146.07px; top: 1141px;\"><a class=\"ql-preview\" rel=\"noopener noreferrer\" target=\"_blank\" href=\"https://www.maa.org/press/periodicals/convergence/leonard-eulers-solution-to-the-konigsberg-bridge-problem\">https://www.maa.org/press/periodicals/convergence/leonard-eulers-solution-to-the-konigsberg-bridge-problem</a><input type=\"text\" data-formula=\"e=mc^2\" data-link=\"https://quilljs.com\" data-video=\"Embed URL\"><a class=\"ql-action\"></a><a class=\"ql-remove\"></a>", user_id: user1.id, notebook_id: notebook1.id)

note3= Note.create(title:"Redux Notes", body:"<p>Imagine your app’s state is described as a plain object. For example, the state of a todo app might look like this:</p><pre class=\"ql-syntax\" spellcheck=\"false\">{
  todos: [{
    text: 'Eat food',
    completed: true
  }, {
    text: 'Exercise',
    completed: false
  }],
  visibilityFilter: 'SHOW_COMPLETED'
}
</pre><p>This object is like a “model” except that there are no setters. This is so that different parts of the code can’t change the state arbitrarily, causing hard-to-reproduce bugs.</p><p>To change something in the state, you need to dispatch an action. An action is a plain JavaScript object (notice how we don’t introduce any magic?) that describes what happened. Here are a few example actions:</p><pre class=\"ql-syntax\" spellcheck=\"false\">{ type: 'ADD_TODO', text: 'Go to swimming pool' }
{ type: 'TOGGLE_TODO', index: 1 }
{ type: 'SET_VISIBILITY_FILTER', filter: 'SHOW_ALL' }
</pre><p>Enforcing that every change is described as an action lets us have a clear understanding of what’s going on in the app. If something changed, we know why it changed. Actions are like breadcrumbs of what has happened. Finally, to tie state and actions together, we write a function called a reducer. Again, nothing magical about it—it’s just a function that takes state and action as arguments, and returns the next state of the app. It would be hard to write such a function for a big app, so we write smaller functions managing parts of the state:</p><pre class=\"ql-syntax\" spellcheck=\"false\">function visibilityFilter(state = 'SHOW_ALL', action) {
  if (action.type === 'SET_VISIBILITY_FILTER') {
    return action.filter
  } else {
    return state
  }
}

function todos(state = [], action) {
  switch (action.type) {
    case 'ADD_TODO':
      return state.concat([{ text: action.text, completed: false }])
    case 'TOGGLE_TODO':
      return state.map((todo, index) =&gt;
        action.index === index
          ? { text: todo.text, completed: !todo.completed }
          : todo
      )
    default:
      return state
  }
}
</pre><p>And we write another reducer that manages the complete state of our app by calling those two reducers for the corresponding state keys:</p><pre class=\"ql-syntax\" spellcheck=\"false\">function todoApp(state = {}, action) {
  return {
    todos: todos(state.todos, action),
    visibilityFilter: visibilityFilter(state.visibilityFilter, action)
  }
}
</pre><p>This is basically the whole idea of Redux. Note that we haven’t used any Redux APIs. It comes with a few utilities to facilitate this pattern, but the main idea is that you describe how your state is updated over time in response to action objects, and 90% of the code you write is just plain JavaScript, with no use of Redux itself, its APIs, or any magic.</p>", user_id: user1.id, notebook_id: notebook1.id)

note4= Note.create(title:"Quiche a la Benedict", body:"<p class=\"ql-align-center\"><img src=\"https://imagesvc.meredithcorp.io/v3/mm/image?url=https%3A%2F%2Fimages.media-allrecipes.com%2Fuserphotos%2F1066135.jpg&amp;w=596&amp;h=596&amp;c=sc&amp;poi=face&amp;q=85\" alt=\"Quiche a la Benedict \"></p><p><br></p><h2>Ingredients</h2><ol><li><span style=\"background-color: rgb(255, 255, 255); color: rgba(0, 0, 0, 0.95);\">1 tablespoon vegetable oil</span></li><li><span style=\"background-color: rgb(255, 255, 255); color: rgba(0, 0, 0, 0.95);\">1 pound fresh asparagus, trimmed and cut into 1/2-inch pieces</span></li><li><span style=\"background-color: rgb(255, 255, 255); color: rgba(0, 0, 0, 0.95);\">1 pinch salt</span></li><li><span style=\"background-color: rgb(255, 255, 255); color: rgba(0, 0, 0, 0.95);\">4 slices Canadian bacon, cut into 1/2-inch dice</span></li><li><span style=\"background-color: rgb(255, 255, 255); color: rgba(0, 0, 0, 0.95);\">3 tablespoons grated onion</span></li><li><span style=\"background-color: rgb(255, 255, 255); color: rgba(0, 0, 0, 0.95);\">1 clove garlic, pressed</span></li><li><span style=\"background-color: rgb(255, 255, 255); color: rgba(0, 0, 0, 0.95);\">4 eggs</span></li><li><span style=\"background-color: rgb(255, 255, 255); color: rgba(0, 0, 0, 0.95);\">¾ cup heavy cream</span></li><li><span style=\"background-color: rgb(255, 255, 255); color: rgba(0, 0, 0, 0.95);\">½ cup biscuit baking mix (such as Bisquick®)</span></li><li><span style=\"background-color: rgb(255, 255, 255); color: rgba(0, 0, 0, 0.95);\">3 tablespoons butter, softened</span></li><li><span style=\"background-color: rgb(255, 255, 255); color: rgba(0, 0, 0, 0.95);\">2 tablespoons grated Parmesan cheese</span></li><li><span style=\"background-color: rgb(255, 255, 255); color: rgba(0, 0, 0, 0.95);\">1 tablespoon Dijon mustard</span></li><li><span style=\"background-color: rgb(255, 255, 255); color: rgba(0, 0, 0, 0.95);\">½ teaspoon salt</span></li><li><span style=\"background-color: rgb(255, 255, 255); color: rgba(0, 0, 0, 0.95);\">½ teaspoon ground black pepper</span></li><li><span style=\"background-color: rgb(255, 255, 255); color: rgba(0, 0, 0, 0.95);\">1 dash hot pepper sauce</span></li><li><span style=\"background-color: rgb(255, 255, 255); color: rgba(0, 0, 0, 0.95);\">1 prepared 9-inch single pie crust</span></li><li><span style=\"background-color: rgb(255, 255, 255); color: rgba(0, 0, 0, 0.95);\">1 cup shredded Colby-Monterey Jack cheese</span></li></ol><p><br></p><p><br></p><p><span style=\"background-color: rgb(255, 255, 255); color: rgba(0, 0, 0, 0.95);\">Directions</span></p><ul><li><span style=\"background-color: rgb(255, 255, 255); color: rgba(0, 0, 0, 0.95);\">Preheat oven to 350 degrees F (175 degrees C).</span></li><li><span style=\"background-color: rgb(255, 255, 255); color: rgba(0, 0, 0, 0.95);\">Heat vegetable oil in a large skillet over medium heat, and cook and stir asparagus until tender, about 10 minutes. Season with a pinch of salt.</span></li><li><span style=\"background-color: rgb(255, 255, 255); color: rgba(0, 0, 0, 0.95);\">Stir Canadian bacon, grated onion, and garlic into the asparagus; cook and stir until the garlic is fragrant, about 1 minute. Remove skillet from heat, cover, and set aside</span></li><li><span style=\"background-color: rgb(255, 255, 255); color: rgba(0, 0, 0, 0.95);\">Whisk eggs, cream, biscuit mix, butter, Parmesan cheese, Dijon mustard, 1/2 teaspoon salt, black pepper, and hot sauce together in a bowl.</span></li><li><span style=\"background-color: rgb(255, 255, 255); color: rgba(0, 0, 0, 0.95);\">Place the pie crust into a 9-inch pie dish; spread asparagus mixture into the crust.</span></li><li><span style=\"background-color: rgb(255, 255, 255); color: rgba(0, 0, 0, 0.95);\">Spread Colby-Monterey Jack cheese over the asparagus mixture in an even layer, and pour the egg mixture slowly over the quiche.</span></li><li><span style=\"background-color: rgb(255, 255, 255); color: rgba(0, 0, 0, 0.95);\">Bake in the preheated oven until the filling is lightly puffed and browned and a toothpick inserted into the center comes out clean, about 40 minutes.</span></li></ul><p><br></p><p><span style=\"background-color: rgb(255, 255, 255); color: rgba(0, 0, 0, 0.95);\">Nutrition Facts</span></p><p><span style=\"background-color: rgb(255, 255, 255); color: rgba(0, 0, 0, 0.95);\">411 calories; 31.9 g total fat; 157 mg cholesterol; 748 mg sodium. 19.5 g carbohydrates; 13 g protein;</span></p><p><br></p><p><br></p>", user_id: user1.id, notebook_id: notebook2.id)


note5= Note.create(title:"Poached Eggs and Asparagus", body:"<h2 class=\"ql-align-center\"><img src=\"https://imagesvc.meredithcorp.io/v3/mm/image?url=https%3A%2F%2Fimages.media-allrecipes.com%2Fuserphotos%2F347739.jpg&amp;w=596&amp;h=399.32000000000005&amp;c=sc&amp;poi=face&amp;q=85\" alt=\"Poached Eggs and Asparagus \"></h2><h2><strong>Ingredients</strong></h2><p><br></p><ol><li>4 eggs</li><li>1 cube chicken bouillon (optional)</li><li>1 pound fresh asparagus, trimmed</li><li>4 slices whole wheat bread</li><li>4 slices Cheddar cheese</li><li>1 tablespoon butter</li><li>salt and pepper to taste</li></ol><p><br></p><p><br></p><h2><strong>Directions</strong></h2><p><br></p><ul><li><strong>Step 1:</strong>	Fill a saucepan half way full of water. Bring to a boil and stir in the bouillon cube until dissolved. Crack one egg into a measuring cup or large spoon and gently slip it into the boiling water. Repeat with remaining eggs. Simmer for about 5 minutes over medium heat. Remove with a slotted spoon and keep warm</li><li><strong>Step 2:</strong>	Meanwhile, Place the asparagus into a saucepan and fill with enough water to cover. Bring to a boil, and cook until asparagus is tender, about 4 minutes. Drain.</li><li><strong>Step 3:</strong>	Toast the bread to your desired darkness. Spread butter onto each piece of toast. Top with a slice of cheese, then a poached egg and finally, asparagus. Season with salt and pepper and serve immediately.</li></ul><p><br></p><p><br></p>", user_id: user1.id, notebook_id: notebook2.id)

note6= Note.create(title:"Good Old Fashioned Pancakes", body:"<h2 class=\"ql-align-center\"><img src=\"https://images.media-allrecipes.com/userphotos/720x405/4948036.jpg\" alt=\"recipe active photo\"></h2><p><br></p><h2><strong>Ingredients</strong></h2><p><br></p><ol><li>1 1/2 cups all-purpose flour</li><li>3 1/2 teaspoons baking powder</li><li>1 teaspoon salt</li><li>1 tablespoon white sugar</li><li>1 1/4 cups milk</li><li>1 egg</li><li>3 tablespoons butter, melted</li></ol><p><br></p><h2><strong>Directions</strong></h2><p><br></p><ul><li><strong>Step1:</strong> In a large bowl, sift together the flour, baking powder, salt and sugar. Make a well in the center and pour in the milk, egg and melted butter; mix until smooth.</li><li><strong>Step 2:</strong> Heat a lightly oiled griddle or frying pan over medium high heat. Pour or scoop the batter onto the griddle, using approximately 1/4 cup for each pancake. Brown on both sides and serve hot.</li></ul><p><br></p><p><br></p><p><span style=\"background-color: rgb(255, 255, 255); color: rgba(0, 0, 0, 0.95);\">Nutrition Facts</span></p><p><span style=\"background-color: rgb(255, 255, 255); color: rgb(45, 45, 45);\">Per Serving:&nbsp;158 calories;&nbsp;5.9&nbsp;g fat;&nbsp;21.7&nbsp;g carbohydrates;&nbsp;4.5&nbsp;g protein;&nbsp;38&nbsp;mg cholesterol;&nbsp;504&nbsp;mg sodium.</span></p>",  user_id: user1.id, notebook_id: notebook2.id)

note7= Note.create(title:"Strawberry Oatmeal Breakfast Smoothie", body:"<h2 class=\"ql-align-center\"><img src=\"https://images.media-allrecipes.com/userphotos/720x405/409456.jpg\" alt=\"recipe active photo\"></h2><h2><br></h2><p><strong>Ingredients</strong></p><p><br></p><ol><li>1 cup soy milk</li><li>1/2 cup rolled oats</li><li>1 banana, broken into chunks</li><li>14 frozen strawberries</li><li>1/2 teaspoon vanilla extract</li><li>1 1/2 teaspoons white sugar</li></ol><p><br></p><h2><strong>Directions</strong></h2><p><br></p><ul><li><strong style=\"color: rgb(45, 45, 45); background-color: rgb(255, 255, 255);\">Step1:</strong>	<span style=\"color: rgb(45, 45, 45); background-color: rgb(255, 255, 255);\"> In a blender, combine soy milk, oats, banana and strawberries. Add vanilla and sugar if desired. Blend until smooth. Pour into glasses and serve.</span></li></ul>",  user_id: user1.id, notebook_id: notebook2.id)